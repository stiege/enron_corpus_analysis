"""
The enron module is a helper module for working with the the email
dataset.
"""

import re
import os

_known_email_metadata = [
    "Message-ID",
    "Date",
    "From",
    "To",
    "Subject",
    "Mime-Version",
    "Content-Type",
    "Content-Transfer-Encoding",
    "X-From",
    "X-To",
    "X-cc",
    "X-bcc",
    "X-Folder",
    "X-Origin",
    "X-FileName"]


def _assemble_email_from_dict(email):
    """
    This function takes the `dict` generated by
    :func:`_parse_email` and reassembles the email string.

    :example:
        >>> email = {msg: "" for msg in (_known_email_metadata)}
        >>> email["Content"] = "Hello"
        >>> assert("Hello" in _assemble_email_from_dict(email))
    """
    msg = []
    for meta in _known_email_metadata:
        if email[meta] is not None:
            msg.append(
                meta + ":" + email[meta] + os.linesep)
    msg.append(email["Content"])
    return "".join(msg)


def _parse_email(file_loc, allow_corrupt=False):
    """
    _parse_email takes a path to an email that is in the common format
    of the enron dataset and parses it into a `dict`.

    :param file_loc: The file location to parse.
    :param allow_corrupt: Select whether a bad parse should raise an
        AssertionError or continue.

    :example:
        >>> email_path = "core/_test_fixtures/maildir/"
        >>> email_path = email_path + "stokley-c/chris_stokley/mid_markt/19."
        >>> email = _parse_email(email_path)
        >>> print(email["From"])
        h..foster@enron.com

    :raises: AssertionError when allow_corrupt is false and a corrupt
        parse is encountered.
    """

    email = {}
    with open(file_loc) as f:
        line_read = None
        for meta in _known_email_metadata:
            if line_read is None:
                line_read = f.readline().strip()
            if not line_read.startswith(meta) and not allow_corrupt:
                raise AssertionError("Corrupt parse on {}".format(meta))
            else:
                email[meta] = re.search(
                    meta + ":(.*)", line_read).group(1).strip()
                if meta == "Subject":
                    line_read = f.readline()
                    while not line_read.startswith("Mime-Version"):
                        email[meta] = email[meta] + line_read
                        line_read = f.readline().strip()
                elif meta == "To":
                    line_read = f.readline()
                    while not line_read.startswith("Subject"):
                        email[meta] = email[meta] + line_read
                        line_read = f.readline().strip()
                elif meta == "Content-Transfer-Encoding":
                    line_read = f.readline()
                    while not line_read.startswith("X-From"):
                        email[meta] = email[meta] + line_read
                        line_read = f.readline().strip()
                else:
                    line_read = None

        msg_content = f.readlines()
        email["Content"] = "".join(msg_content)
        email["Content"] = email["Content"].strip()

    return email
